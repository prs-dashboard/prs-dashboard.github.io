<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub PR dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css"
        integrity="sha512-1sCRPdkRXhBV2PBLUdRb4tMg1w2YPf37qatUFeS7zlBy7jJI8Lf4VHwWfZZfpXtYSLy85pkm9GaYVYMfw5BC1A=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js" crossorigin="anonymous"
        referrerpolicy="no-referrer"></script>
    <link rel="icon" sizes="any" href='data:image/svg+xml,%3Csvg version="1.1" viewBox="0 0 12 12" xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg"%3E%3Cellipse cx="6.35" cy="6.35" rx="5.588" ry="5.588" fill="white" stroke-width="0"%2F%3E%3Cpath d="m2.3813 6.3475c0 1.8521 0 3.7042 2.6458 3.7065 0.00937-1.033 0-1.8614 0-2.6458h2.6458c0.00125 0.78446 0.00125 1.8491 0 2.6458 2.6458 0 2.6458-1.8544 2.6458-3.7065s0-3.7042-2.6458-3.7018c-0.011341 1.2395 0 2.6458 0 2.6458h-2.6458c-5.1e-6 -1.5689 0.015757-1.7943 0-2.6458-2.6458-0.00234-2.6458 1.8497-2.6458 3.7018z" fill="none" stroke="%23000" stroke-linecap="square" stroke-width="1"%2F%3E%3C%2Fsvg%3E'>

    <style>
        .pr h3 {
            font-size: medium;
        }

        .avatar {
            width: 1em;
            height: 1em;
            border-radius: 1em;
            margin-right: 0.1em
        }

        .pr-files::after {
            font: var(--fa-font-regular);
            content: " \f016";
        }

        .pr-comments::after {
            font: var(--fa-font-regular);
            content: " \f075";
        }

        .pr-commits::after {
            font: var(--fa-font-regular);
            content: " \f292";
        }

        .pr-list li {
            display: inline-block;
        }

        .pr-labels::after {
            font: var(--fa-font-regular);
            content: " \f02e";
        }

        div.pr-files,
        div.pr-comments,
        div.pr-commits-count,
        div.pr-labels,
        .pr-state,
        .pr-reviewed,
        .pr-user,
        .pr-merge-status,
        .pr-created-at,
        .pr-updated-at,
        .pr-target-branch {
            display: inline
        }

        .pr-target-branch::before {
            /** Doesnt work with --fa-font-regular **/
            content: " \f126 ";
            font: var(--fa-font-solid);
            margin-left: 0.5em;
            font-size: 0.7em;
            margin-right: 0.1em;
        }

        /* .pr-author::before {
            content: "by: ";
        } */

        .pr-target-branch,
        .pr-author {
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 15em;
            display: inline-block;
            overflow-x: hidden;
            vertical-align: top;
            /* to fix extra space on overflow */
        }

        /** usually for already merged PRs, hence no need to display mergeability **/
        .pr-merge-status-unknown {
            display: none;
            visibility: hidden;
        }

        .pr-comments::before,
        .pr-labels::before,
        .pr-reviewed::before,
        .pr-files::before,
        .pr-merge-status::before {
            content: " / "
        }

        .pr-title.pr-state-draft::before {
            font: var(--fa-font-solid);
            content: "\f110  ";
        }

        .pr-title.pr-state-merged::before {
            /** Doesnt work with --fa-font-regular **/
            font: var(--fa-font-solid);
            content: "\f387  ";
        }

        .pr-title.pr-state-closed::before {
            font: var(--fa-font-solid);
            content: "\f00d  ";
        }

        .pr-title.pr-state-open::before {
            font: var(--fa-font-regular);
            content: "\f111  ";
        }

        .pr-commit-check-status-failure::before {
            font: var(--fa-font-regular);
            content: "\f057";
        }

        .pr-commit-check-status-success::before {
            font: var(--fa-font-regular);
            content: "\f058";
        }

        .pr-commit-check-status-unknown::before {
            font: var(--fa-font-regular);
            content: "\f059";
        }

        .pr-commit-check-status {
            vertical-align: middle;
            text-decoration: none;
        }

        .repo-title {
            display: block;
            padding: 5px;
            background-color: lightgray;
            margin-top: 0.5em;
        }

        .commit-section div {
            display: inline;
        }

        .card {
            max-width: 400px;
            width: 400px;
            margin: 0.2em;
        }

        .card-body {
            padding-top: 8px;
            padding-bottom: 8px;
        }

        .card-header {
            padding-bottom: 4px;
        }

        .card-footer {
            display: flex;
            justify-content: space-between;
            padding-top: 4px;
        }

        .pr-title {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 360px;
            width: 360px;
            display: inline-block;
        }

        list#repo-list li,
        list#author-list li {
            display: inline-block;
            margin: 0 1em 0 0;
        }

        list#author-list:nth-child(0) {
            clear: both;
        }

        /* Inline checkboxes */
        .form-group {
            display: inline-block;
            margin-left: 0.5em;
        }

        .repo-title .form-group {
            font-size: 0.5em;
        }

        form {
            display: inline-block;
        }

        /* Floating header */
        header {
            position: fixed;
            background: var(--bs-body-bg);
            top: 0px;
            z-index: 10;
            width: 100%;
            box-shadow: 0px 0px 5px -1px black;
        }

        header {
            display: grid;
            grid-template-columns: 20fr 1fr;
        }

        header div {
            display: grid;
            grid-column-start: 1;
        }

        header div#color {
            display: grid;
            grid-column-start: 2;
            grid-row-start: 1;
            grid-row-end: 100;
        }

        main {
            padding-top: 3em;
            scroll-margin-top: 4em;
        }
    </style>
</head>

<body>
    <header>
        <div>
            <list id="repo-list">
                Repositories:
            </list>
        </div>
        <div>
            <form class="author-filter" id="author-list">
                Authors:
            </form>
        </div>
        <div>
            <form class="assignee-filter" id="assignee-list">
                Reviewers:
            </form>
        </div>
        <div id="color">&nbsp;</div>
    </header>
    <main id="repo-container">
    </main>
    <script defer>
        // https://stackoverflow.com/a/6234804
        const escapeHtml = (unsafe) => {
            if (unsafe === null || unsafe === undefined)
                return unsafe;

            return unsafe.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;').replaceAll('"', '&quot;').replaceAll("'", '&#039;');
        }

        function requestBody(request_repo, request_authors, assignees, query, request_limit) {
            let authors_clause = '';
            if (authors.length > 0) {
                authors_clause = 'author:' + authors.join(' author:');
            }

            let assignees_clause = '';
            if (assignees.length > 0) {
                assignees_clause = 'assignee:' + assignees.join(' assignee:');
            }

            if (!query)
                query = '';

            return `{ search(
    query: "repo:${request_repo} is:pr ${authors_clause} ${assignees_clause} sort:created-desc ${query}"
    type: ISSUE
    first: ${request_limit}
  ) {
    edges {
      node {
        ... on PullRequest {
          number
          url
          title
          createdAt
          state
          isDraft
          updatedAt
          mergeable
          baseRefName
          changedFiles
          files(last: 60) {
            nodes {
              changeType
              path
              deletions
              additions
            }
            totalCount
          }
          labels (last: 20) {
            totalCount
            nodes {
              name
              color
            }
          }
          reviews(last: 1) {
            edges {
              node {
                id
                state
              }
            }
          }
          author {
            avatarUrl
            login
            url
            ... on User {
              name
            }
            ... on Organization {
              id
              name
            }
            ... on EnterpriseUserAccount {
              name
            }
          }
          commits(last: 1) {
            totalCount
            edges {
              node {
                commit {
                  commitUrl
                  oid
                  statusCheckRollup {
                    state
                  }
                }
              }
            }
          }
          assignees(first: 10) {
            nodes {
              login
              name
              avatarUrl
              url
            }
          }
          reviewRequests(first: 100) {
            nodes {
              requestedReviewer {
                ... on User {
                  name
                  login
                  avatarUrl
                  url
                }
              }
            }
          }
          comments {
            totalCount
          }
        }
      }
    }
  }
}`
        }

        function getParameters(name) {
            let result = [];
            for (const [k, v] of new URL(document.location).searchParams) {
                if (k === name)
                    result.push(v);
            }

            return result;
        }

        function getParameter(name) {
            const params = getParameters(name);
            if (params && params.length > 0) {
                return params[params.length - 1];
            }

            return null;
        }

        const DEAFULT_PRS_COUNT = 10;
        function getRepos() {
            let repos = [];
            for (let repo of getParameters('repo')) {
                let [repo_name, prs_count] = decodeURI(repo).split(':');
                if (prs_count === undefined)
                    prs_count = DEAFULT_PRS_COUNT;
                let repo_object = {}
                repo_object[repo_name] = prs_count;
                repos.push(repo_object);
            }

            return repos;
        }

        async function isValidGithubToken(github_token) {
            if (github_token) {
                let response = await doGithubGraphQLRequest(`{rateLimit { remaining }}`, github_token);
                console.log(response);
                if (response && response.data && response.data.rateLimit.remaining > 0)
                    return true;
            }

            return false;
        }

        async function getValidGithubToken(github_token) {
            const GITHUB_TOKEN_PROMPT = 'For querying github API we need a valid token, scope of token depends on repos and authors you want to track';
            const GITHUB_TOKEN_INVALID_MESSAGE = 'It looks like GitHub token you provided either invalid or expired, please check console for more information.';

            while (! await isValidGithubToken(github_token)) {
                const message = github_token ? GITHUB_TOKEN_INVALID_MESSAGE + '\n' + GITHUB_TOKEN_PROMPT : GITHUB_TOKEN_PROMPT;

                github_token = prompt(message);
            }

            return github_token;
        }

        // Allow user to specify namespace to use different tokens for different repos/access rights.
        const namespace = getParameter('namespace');
        const github_token_storage_name = namespace && namespace.length > 0 ? namespace + ':github_token' : 'github_token';
        async function resetGithubToken() {
            localStorage.removeItem(github_token_storage_name);
            return await getValidGithubToken(null);
        }

        async function getGitHubToken() {
            let github_token = await getValidGithubToken(localStorage.getItem(github_token_storage_name));
            localStorage.setItem(github_token_storage_name, github_token);

            return github_token;
        }

        const authors = getParameters('author');
        const repos = getRepos();

        const assignees = getParameters('assignee');
        const query = getParameter('query');

        async function doGithubGraphQLRequest(request, github_token) {
            let response = await fetch('https://api.github.com/graphql', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${github_token}`,
                },
                // The payload must contain a string called query
                // https://docs.github.com/en/graphql/guides/forming-calls-with-graphql#communicating-with-graphql
                body: JSON.stringify({ query: request })
            });
            // console.log(response);
            return await response.json();
        }

        function createPRNode(pr) {
            let commit = pr.commits.edges[0].node.commit;
            // console.log(commit, commit.oid.slice(8));
            let review = null;
            try {
                review = pr.reviews.edges[0].node;
            }
            catch (e) {
                //console.log(e);
            }
            const pr_state = pr.isDraft ? 'draft' : pr.state.toLowerCase();
            const pr_target_branch = pr.baseRefName ? escapeHtml(pr.baseRefName) : "";
            const commit_status = commit.statusCheckRollup ? commit.statusCheckRollup.state.toLowerCase() : 'unknown';
            const pr_card = `
<li class="pr card pr-state-${pr_state} author-${pr.author.login.toLowerCase()}">
    <div class="card-header"><a class="pr-title pr-state-${pr_state}"
            href="${pr.url}"
            title="#${pr.number} (${pr_state}) ${escapeHtml(pr.title)}">${pr.title}</a>
        </div>
    </div>
    <div class="card-body">
        <div class="pr-attribute pr-user pr-author" title="${escapeHtml(pr.author.name)}"><a
                href="${pr.author.url}"><img class="avatar"
                    src="${pr.author.avatarUrl}">${pr.author.login}</a>
        </div>
        <div class="pr-attribute pr-target-branch" title="${pr_target_branch}">${pr_target_branch}</div>
        <div class="commit-section">
            <div class="pr-attribute pr-commit"><a class="pr-commit-check-status pr-commit-check-status-${commit_status}"
                    href="${commit.commitUrl}/status-details" title="${commit_status}"></a>&nbsp;<a
                    href="${commit.commitUrl}">${commit.oid.slice(0, 8)}</a>
            </div>
            <div class="pr-attribute pr-commits-count">(${pr.commits.totalCount})</div>
            <div class="pr-attribute pr-files" title="${(() => {
                let files = [];
                for (file of pr.files.nodes) {
                    files.push(`${file.changeType.slice(0, 1)}\t-${file.deletions}/+${file.additions}\t${file.path}`);
                }
                return files.join('\n');
            })()}">${pr.changedFiles}</div>
            <div class="pr-attribute pr-merge-status pr-merge-status-${pr.mergeable.toLowerCase()}">${pr.mergeable.toLowerCase()}</div>
        </div>
        ${(() => {
                    if (pr.assignees && pr.assignees.nodes.length > 0) {
                        let assignee = pr.assignees.nodes[0];
                        return `
        <div class="pr-attribute pr-reviewer pr-user" title="${escapeHtml(assignee.name)}"><a
                href="${assignee.url}"><img class="avatar"
                    src="${assignee.avatarUrl}">${assignee.login}</a>
        </div>
        `
                    } else {
                        return `<div class="pr-attribute pr-reviewer pr-user pr-reviewer-missing">NO REVIEWER</div>`
                    }
                })()}
        <div class="pr-attribute pr-reviewed">${review ? review.state.toLowerCase() : 'NOT REVIEWED'
                }</div >
            <div class="pr-attribute pr-comments">${pr.comments.totalCount}</div>
            <div class="pr-attribute pr-labels" title="${(() => {
                let labels = '';
                for (label of pr.labels.nodes)
                    labels += label.name + '\n';
                // Trim trailing '\n';
                return labels.slice(0, labels.length - 1);
            })()}">
                ${pr.labels ? pr.labels.totalCount : 0}</div>
            </div >
            </div >
            <div class="card-footer">
                <div class="pr-attribute pr-created-at pr-time" title="created at: ${moment(pr.createdAt).format('LLLL')}">
                    <time data-time="${pr.createdAt}">${moment(pr.createdAt).fromNow()}</time>
                </div>
                <div class="pr-attribute pr-updated-at pr-time" title="last updated at: ${moment(pr.updatedAt).format('LLLL')}">updated:
                    <time data-time="${pr.updatedAt}">${moment(pr.updatedAt).fromNow()}</time>
                </div>
            </div>
</li > `;
            let pr_node = document.createElement('pull-request')
            pr_node.innerHTML = pr_card;
            pr_node.github_data = pr;

            return pr_node;
        }

        function createRepoNode(repo_name, prs_data) {
            const repo_template = `
            <section id="${repo_name}" style="container-fluid">
    <h2 class="repo-title"><a class="repo-name" href="https://github.com/${repo_name}/pulls">${repo_name}</a>
    <form class="pr-filters">
    </form>
    </h2>
    <list class="pr-list">
    </list>
</section>`;
            let repo_node = document.createElement('repositoty');
            repo_node.innerHTML = repo_template;

            let pr_list_node = repo_node.querySelector('.pr-list');

            for (pr of prs_data) {
                pr_list_node.appendChild(createPRNode(pr['node']));
            }

            let pr_filters_node = repo_node.querySelector('.pr-filters');
            const pr_states = ['merged', 'open', 'closed', 'draft'];
            for (pr_state of pr_states) {
                let pr_of_state = pr_list_node.querySelectorAll(`.pr.card.pr-state-${pr_state}`);
                let checkbox_name = `${repo_name}-checkbox-${pr_state}`;
                const check_html = `<div class="form-group form-check">
                    <input type="checkbox" class="form-check-input" id="${checkbox_name}" checked>
                    <label class="form-check-label" for="${checkbox_name}">${pr_state} (${pr_of_state.length})</label>
                </div>`
                let filter_node = document.createElement('filter');
                filter_node.innerHTML = check_html;
                pr_filters_node.appendChild(filter_node);

                let checkbox_node = filter_node.querySelector('input[type=checkbox]');
                checkbox_node.onchange = function () {
                    const display = checkbox_node.checked ? '' : 'none';
                    for (pr of pr_of_state) {
                        pr.style.display = display;
                    }
                };
            }

            return repo_node;
        }

        async function buildRepoPRs(repos) {
            const github_token = await getGitHubToken();
            for (repo_kv of repos) {
                const repo_name = Object.keys(repo_kv)[0];
                const prs_to_fetch = Object.values(repo_kv)[0];
                console.log("doing ", repo_name);
                let response = await doGithubGraphQLRequest(requestBody(repo_name, authors, assignees, query, prs_to_fetch), github_token);
                let prs_data = response['data']['search']['edges'];
                console.log(`got ${prs_data.length} PRs from API`);

                document.getElementById('repo-container').appendChild(createRepoNode(repo_name, prs_data));
            }
        }

        buildRepoPRs(repos);

        // Set up Repos/authors/assignees/query fields
        (function () {
            const repo_list_node = document.getElementById('repo-list');
            for (repo_kv of repos) {
                const repo_name = Object.keys(repo_kv)[0];
                let r = document.createElement('li');
                const repo_template = `<a class="repo-name" href="#${repo_name}">${repo_name}</a>`;
                r.innerHTML = repo_template;
                repo_list_node.append(r);
            }

            function setUpFilters(filter_type, users) {
                const list_node = document.getElementById(`${filter_type}-list`);
                if (users.length == 0)
                    list_node.style.display = 'none';

                for (user of users) {
                    let node = document.createElement(`${filter_type}-check`);
                    const checkbox_name = `${filter_type}-${user}-checkbox`;
                    const template = `<div class="form-group form-check">
                        <input type="checkbox" class="form-check-input" id="${checkbox_name}" checked ${filter_type}="${user}">
                        <label class="form-check-label" for="${checkbox_name}">${user}</label>
                    </div>`;

                    node.innerHTML = template;

                    let checkbox_node = node.querySelector('input[type=checkbox]');
                    checkbox_node.onchange = function () {
                        const user_name = checkbox_node.attributes[`${filter_type}`].value;
                        const display = checkbox_node.checked ? '' : 'none';
                        console.log(checkbox_node);

                        for (pr of document.querySelectorAll(`.pr.${filter_type}-${user_name}`)) {
                            pr.style.display = display;
                        }
                    };

                    list_node.append(node);
                }
            }
            setUpFilters('author', authors);
            setUpFilters('assignee', assignees);

            const title = getParameter('title');
            if (title) {
                document.title = title;
            }


            const color = getParameter('color');
            function setColor(new_color) {
                if (new_color) {
                    const color_node = document.getElementById('color');
                    if (!CSS.supports('color', new_color)) {
                        console.log(`Invalid color value: ${new_color}, would not change accents not favicon color`);
                        color.display = 'none';
                        return;
                    }

                    new_color = encodeURIComponent(new_color);
                    var icon = document.querySelector('link[rel="icon"]');
                    icon.href = icon.href.replace('fill="white"', `fill="${new_color}"`);
                    color_node.style.background = new_color;
                }
            }
            setColor(color);

            function updateTimeValues() {
                for (t of document.getElementsByTagName('time')) {
                    let human_time = moment(t.dataset.time).fromNow();
                    console.log(t, human_time);
                    t.innerText = human_time;
                }
            }
            // Update time values once in a while
            window.setInterval(updateTimeValues, 5*60*1000);

        })();

    </script>
</body>

</html>
